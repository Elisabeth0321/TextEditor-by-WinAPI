# Структура проекта TextEditor

## Обзор

Проект был реструктурирован с монолитного подхода на модульную архитектуру, следуя принципам SOLID и принципам чистого кода.

## Модульная архитектура

### 1. Application (Главный класс приложения)
**Файлы:** `Application.h`, `Application.cpp`

**Ответственность:**
- Координация работы всех модулей
- Инициализация приложения
- Главный цикл сообщений
- Обработка команд меню
- Управление жизненным циклом приложения

**Ключевые методы:**
- `initialize()` - инициализация всех модулей
- `run()` - главный цикл приложения
- `handleMenuCommand()` - обработка команд меню
- `handleTextChange()` - обработка изменений текста

### 2. WindowManager (Управление окнами)
**Файлы:** `WindowManager.h`, `WindowManager.cpp`

**Ответственность:**
- Создание и управление главным окном
- Обработка сообщений окна
- Управление заголовками окон
- Центрирование диалогов
- Обработка событий пользователя

**Ключевые методы:**
- `registerWindowClass()` - регистрация класса окна
- `createMainWindow()` - создание главного окна
- `updateWindowTitle()` - обновление заголовка
- `showAboutDialog()` - показ диалога "О программе"

### 3. FileManager (Управление файлами)
**Файлы:** `FileManager.h`, `FileManager.cpp`

**Ответственность:**
- Открытие и сохранение файлов
- Работа с различными кодировками (UTF-8, ANSI)
- Управление состоянием файла (изменен/не изменен)
- Диалоги открытия/сохранения файлов

**Ключевые методы:**
- `openTextFile()` - открытие текстового файла
- `saveTextFile()` - сохранение файла
- `saveTextFileAs()` - сохранение с выбором имени
- `promptSaveChanges()` - запрос на сохранение изменений

### 4. EditControlManager (Управление текстовым редактором)
**Файлы:** `EditControlManager.h`, `EditControlManager.cpp`

**Ответственность:**
- Создание и управление EDIT-контролом
- Работа с текстом (вырезание, копирование, вставка)
- Управление шрифтами
- Обработка изменений текста

**Ключевые методы:**
- `createEditControl()` - создание контрола
- `setText()` / `getText()` - работа с текстом
- `cutText()`, `copyText()`, `pasteText()` - операции с буфером обмена
- `setFont()` - установка шрифта

### 5. DarkScreenManager (Управление темным экраном)
**Файлы:** `DarkScreenManager.h`, `DarkScreenManager.cpp`

**Ответственность:**
- Показ/скрытие темного экрана
- Анимация спрайта
- Отслеживание неактивности пользователя
- Управление таймерами

**Ключевые методы:**
- `showDarkScreen()` - показ темного экрана
- `hideDarkScreen()` - скрытие темного экрана
- `handleUserActivity()` - обработка активности пользователя
- `handleTimer()` - обработка таймеров

## Преимущества новой архитектуры

### 1. Разделение ответственности (Single Responsibility Principle)
Каждый класс отвечает за одну конкретную область функциональности.

### 2. Слабая связанность (Loose Coupling)
Модули взаимодействуют через четко определенные интерфейсы и callback'и.

### 3. Высокая когезия (High Cohesion)
Связанная функциональность сгруппирована в одном модуле.

### 4. Расширяемость
Легко добавлять новые функции или изменять существующие без влияния на другие модули.

### 5. Тестируемость
Каждый модуль можно тестировать независимо.

### 6. Читаемость кода
Код стал более структурированным и понятным.

## Использование

### Старый подход (монолитный):
```cpp
// Все в одном файле TextEditor.cpp (823 строки)
// Смешанная ответственность
// Сложно поддерживать и расширять
```

### Новый подход (модульный):
```cpp
// Главный файл TextEditor_New.cpp (только 50 строк)
#include "Application.h"

int APIENTRY wWinMain(...)
{
    Application app(hInstance);
    if (!app.initialize()) return -1;
    return app.run(nCmdShow);
}
```

## Файловая структура

```
WindowsProject1/
├── Application.h              # Главный класс приложения
├── Application.cpp
├── WindowManager.h            # Управление окнами
├── WindowManager.cpp
├── FileManager.h              # Управление файлами
├── FileManager.cpp
├── EditControlManager.h       # Управление текстовым редактором
├── EditControlManager.cpp
├── DarkScreenManager.h        # Управление темным экраном
├── DarkScreenManager.cpp
├── TextEditor_New.cpp         # Новая точка входа
├── TextEditor.cpp             # Старый монолитный код (для сравнения)
├── framework.h                # Системные заголовки
├── Resource.h                 # Ресурсы приложения
└── PROJECT_STRUCTURE.md       # Этот файл
```

## Следующие шаги

1. **Тестирование** - добавить unit-тесты для каждого модуля
2. **Документация** - расширить JSDoc комментарии
3. **Обработка ошибок** - улучшить обработку исключений
4. **Конфигурация** - вынести настройки в отдельный файл
5. **Логирование** - добавить систему логирования
6. **Плагины** - возможность расширения функциональности

## Заключение

Рефакторинг успешно завершен. Код стал более модульным, читаемым и поддерживаемым. Каждый модуль имеет четко определенную ответственность и может развиваться независимо от других.
